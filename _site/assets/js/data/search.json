[
  
  {
    "title": "자바스크립트의 비동기",
    "url": "/posts/javascript-asynchronous/",
    "categories": "javascript",
    "tags": "javascript, asynchronous",
    "date": "2024-11-21 17:45:00 +0900",
    





    
    "snippet": "자바스크립트의 동기와 비동기자바스크립트는 한 번에 하나의 작업만 수행할 수 있는 싱글스레드 언어입니다. 그렇기 때문에 원래라면 동기적인 실행을 해야합니다. 동기적 처리는 직관적이고 간단하지만, 작업 시간이 오래 걸리면 전체적인 성능이나 사용자 경험에 좋지 않은 영향을 줄 수 있습니다.이러한 문제점들을 위해 자바스크립트에 ‘비동기’라는 개념을 도입하여,...",
    "content": "자바스크립트의 동기와 비동기자바스크립트는 한 번에 하나의 작업만 수행할 수 있는 싱글스레드 언어입니다. 그렇기 때문에 원래라면 동기적인 실행을 해야합니다. 동기적 처리는 직관적이고 간단하지만, 작업 시간이 오래 걸리면 전체적인 성능이나 사용자 경험에 좋지 않은 영향을 줄 수 있습니다.이러한 문제점들을 위해 자바스크립트에 ‘비동기’라는 개념을 도입하여, 특정 작업이 끝날 때까지 기다리지 않고 다른 작업들도 동시에 수행할 수 있게합니다.자바스크립트의 비동기 특징비동기는 메인스레드가 작업을 받아 다른 곳에 인가하여 처리하게 하고, 그 작업이 완료되면 콜백함수를 받아 실행하는 방식입니다. 쉽게 말해, 작업을 백그라운드에 처리하게해서 멀티로 작업을 동시에 처리할 수 있습니다. 예를들어, 서버에 데이터를 요청하고 응답을 받아야하는 작업이 있다면, 응답이 오는 것과 상관없이 다른 작업을 계속 이어나가 병렬적으로 작업을 동시에 처리가 가능해져 프로그램의 흐림이 멈추거나 지연되지 않게 됩니다. 따라서 Task들이 병렬적으로 동시에 처리되고, 총 코드 실행시간은 획기적으로 줄어듭니다.대표적으로 웹에서 비동기 처리를 가능하게 하는 Ajax 기술이 있습니다. 다른 서버에게 데이터를 요청할 때, XMLHttpRequest 객체나 혹은 fetch 메서드로 요청하게 되는데, 서버로부터 응답을 기다리는 동안에도 사용자와의 인터랙션을 유지할 수 있으므로 사용자 경험을 향상시킬 수 있습니다.브라우저라는 소프트웨어가 멀티스레드이기 때문에 메인 자바스크립트 스레드를 차단하지 않고, 다른 스레드를 사용하여 Web API의 작업을 동시 처리가 가능합니다.비동기 처리의 문제점Asynchronous는 요청한 작업의 완료 여부를 기다리지 않고 자신의 다음 작업을 계속 수행해 나갑니다. 그런데 만약 그 다음 실행할 작업이 이전에 요청한 작업의 결과가 반드시 필요한 경우에 문제가 발생합니다. 또한 서버로부터 데이터를 받을 때, 비동기 함수의 결과가 동기적으로 실행되어야 하는 코드에 영향을 줄 때 문제가 발생합니다.비동기를 알맞게 처리하기 위한 기법비동기와 콜백함수콜백함수란 함수의 매개변수에 함수 자체를 넘겨, 함수 내에서 매개변수 함수를 실행하는 기법입니다. 콜백 함수는 비동기 함수에서 작업 결과를 전달받아 처리하는데 사용되어 작업 순서를 맞출 수 있게 됩니다. 다만, 너무 복잡하게 얽힌 비동기 처리로 인한 콜백 함수 받식은 코드 복잡도를 증가시켜, 콜백 지옥에 빠질 수 있는 단점이 있습니다.비동기와 PromisePromise 객체는 비동기 처리릉 위한 전용 객체로 탄생하여, 비동기 작업의 성공 또는 실패와 그 결과값을 나타내는 객체입니다. 그래서 Promise를 사용하면 비동기 작업을 쉽고 깔끔하게 연결할 수 있습니다. 하지만, then 핸들러 함수의 남용으로 인해 Promise Hell이 발생할 수 있습니다.비동기와 async/awaitAsync/await는 프로미스를 기반으로 하지만, 코드를 동기처럼 작성할 수 있게 해줍니다.콜백 함수는 복잡하지 않고 비교적 심플한 비동기 작업을 처리할 때 사용하면, 오히려 프로미스 방식보다 더 좋을 수 있습니다. 반면에 비교적 복잡한 비동기 작업을 처리할 때는 Promsie 객체를 사용하면 코드를 보다 간결하게 작성할 수 있습니다.자바스크립트 엔진 구동 환경자바스크립트를 실행하는 소프트웨어  웹 브라우저  런타임인 Node.js브라우저(크롬) 내부 구성도브라우저는 웹 사이트를 화면에 보여주기 위해 여러가지 역할을 하는 부품들로 이루어져 있습니다.Call Stack: 자바스크립트 엔진이 코드 실행을 위해 사용하는 메모리 구조Heap: 동적으로 생성된 자바스크립트 객체가 저장되는 공간Web APIs: 브라우저에서 제공하는 API 모음으로, 비동기적으로 실행되는 작업들을 전담하여 처리 (AJAX 호출, 타이머 함수, DOM 조작 등)Callback Queue: 비동기적 작업이 완료되면, 실행되는 함수들이 대기하는 공간Event Loop: 비동기 함수들을 적절한 시점에 실행시키는 관리자Event Table: 특정 이벤트(timeout, click, mouse 등)가 발생했을 때, 어떤 callback 함수가 호출되어야 하는지를 알고있는 자료구조Web APIs브라우저에서 멀티스레드로 구현되어 있습니다. 그래서 브라우저는 비동기 작업에 대해 메인스레드를 차단하지 않고, 다른 스레드를 사용하여 동시에 처리할 수 있습니다.Web APIs의 종류  DOM: HTML 문서의 구조와 내용을 표현하고 조작할 수 있는 객체  XMLHttpRequest: 서버와 비동기적으로 데이터를 교환할 수 있는 객체. AJAX 기술의 핵심  Timer API: 일정한 시간 간격으로 함수를 실행하거나 지연시키는 메소드들을 제공  Console API: 개발자 도구에서 콘솔 기능을 제공  Canvas API: canvas 요소를 통해 그래픽을 그리거나 애니메이션을 만들 수 있는 메소드들을 제공ㅇ  Geolocation API: 웹 브라우저에서 사용자의 현재 위치 정보를 얻을 수 있는 메소드들을 제공모든 Web APIs들이 비동기로 동작하는 것은 아니다. Web API에는 동기적으로 처리되는 것과 비동기적으로 처리되는 것이 모두 있다. 예를 들어, DOM API나 Console API는 동기적으로 처리되고, XMLHttpRequest나 Timer API는 동기적으로 처리된다.Callback Queue의 종류Task Queue: setTimeout, setInterval, fetch, addEventListener와 같이 비동기로 처리되는 함수들의 콜백 함수가 들어가는 큐Microtask Queue: promise.then, process.nextTick, MutationObserver와 같이 우선적으로 비동기로 처리되는 함수들의 콜백 함수가 들어가는 큐 (처리 우선순위가 더 높음)Callback Queue의 종류에 따라 이벤트 루프가 Call Stack으로 옮기는 순서가 달라진다. 일반적으로 Microtask Queue가 가장 우선순위가 높아 먼저 Microtask Queue를 처리하여 먼저 비우고, 그 다음 Task Queue의 콜백을 처리한다.자바스크립트 비동기와 이벤트 루프오래 걸리고 반복적인 작업들은 자바스크립트 엔진이 아닌 ‘브라우저 내부의 멀티 스레드인 Web APIs에서 비동기 + 논블로킹’으로 처리됩니다. ‘비동기와 논블로킹’은 메인스레드가 작업을 다른 곳에 요청하여 대신 실행하고, 그 작업이 완료되면 이벤트나 콜백함수를 받아 결과를 실행시킵니다.이벤트 루프이벤트 루프란 브라우저의 동작 타이밍을 제어하는 관리자입니다. 싱글스레드인 자바스크립트의 작업을 멀티스레드로 돌려 작업을 동시에 처리하게 하던가, 또는 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인지 결정하는 세심한 컨트롤을 하기 위해 존재합니다. 브러우저 내부의 Call Stack, Callback Queue, Web APIs 등의 요소들을 모니터링하면서 비동기적으로 실행되는 작업들을 관리하고, 이를 순서대로 처리하여 프로그램의 실행 흐름을 제어합니다.이벤트 루프 동작 과정싱글스레드인 자바스크립트에서 비동기 작업을 할 수 있는 이유는 이벤트 루프가 자바스크립트 엔진과 브라우저의 웹 API를 연결하여 비동기적인 일 처리를 가능하게 하기 때문입니다. 다만, 모든 자바스클비트 코드를 비동기로 처리할 수 있는 것은 아닌데, 대표적으로 setTimeout, fetch, addEventListener가 있습니다.이벤트 루프(Event Loop)는 이 비동기 함수 작업을 Web API에 옮기는 역할을 하고 작업이 완료되면, 콜백을 Queue에 적재했다가 다시 자바스크립트 엔진에 적재했다가 다시 자바스크립트 엔진에 적재해 수행시키는 일종의 ‘작업을 옮기는 역할’만 합니다. 작업을 처리하는 주체는 자바스크립트 엔진과 웹 API입니다. 그래서 이벤트 루프는 Call Stack에 혀재 실행중인 작업이 있는지, Task Queue에 대기중인 작업이 있는지 반복적으로 확인하는 일종의 무한 루프만을 돌고 있고, 대기 작업이 있다면 작업을 몲겨주는 형태로 동작한다고 볼 수 있습니다.이벤트 기반 프로그래밍비동기 자바스크립트를 브라우저 Web APIs에게 맡기고, 백그라우드 작업이 끝난 결과를 콜백 함수 형태로 큐(Callback Queue)에 넣고 처리 준비가 되면, 호출 스택(Call Stack)에 넣어 마무리 작업을 합니다.이벤트 기반 프로그래밍으로 비동기 작업을 쉽게 처리할 수 있고, 멀티스레드 언어에 비해 단순하고 직관적인 코드 작성을 가능하게 하며, 브라우저와 같은 환경에서도 안정적인 실행을 가능하게 하여 사용자와의 상호작용을 높일 수 있습니다."
  },
  
  {
    "title": "Jekyll Chripy 테마로 Github Blog 만들기",
    "url": "/posts/git-blog-by-jekyll/",
    "categories": "Blogging",
    "tags": "typography",
    "date": "2024-11-06 11:33:00 +0900",
    





    
    "snippet": "서론대학생 때 사용하던 티스토리 대신 조금 더 개발자스러운 블로그를 만들고 싶었습니다. 벨로그와 깃허브 블로그 중 고민하다가 조금더 저만의 스타일을 보여줄 수 있는 깃허브 블로그로 결정했습니다! Markdown으로 포스팅하는 법도 익힐겸, 만들면서 겪었던 문제와 어떻게 해결했는지를 다루는 포스팅해보려고 합니다. 깃허브 블로그 만드는데 3시간 정도 걸렸...",
    "content": "서론대학생 때 사용하던 티스토리 대신 조금 더 개발자스러운 블로그를 만들고 싶었습니다. 벨로그와 깃허브 블로그 중 고민하다가 조금더 저만의 스타일을 보여줄 수 있는 깃허브 블로그로 결정했습니다! Markdown으로 포스팅하는 법도 익힐겸, 만들면서 겪었던 문제와 어떻게 해결했는지를 다루는 포스팅해보려고 합니다. 깃허브 블로그 만드는데 3시간 정도 걸렸고, 크게 어려운 부분은 없기 때문에 본인이 개발자라면 한 번쯤 만들어보는 것도 추천합니다!개발 과정1. Git 레포지토리 생성본인의 깃허브 계정에 레포지토리를 생성합니다. 여기서 레포지토리 명은 “username.github.io”로 작성합니다. 본인의 username 대신 다른 걸로 지정해도 되지만, 조금더 설정할 것이 늘어난다고 하니 이왕이면 본인 username으로 지정하면 좋겠습니다.레포지토리 Settings &gt; Pages에 들어가서 설정을 해줘야합니다.Build and deployment에서 Source &gt; Deploy from a branch으로 수정해줍니다!2. Git 프로젝트 Clone이제 로컬 환경에서 글을 쓸 수 있어야하기 때문에 project를 clone 해줍니다.$ git clone https://github.com/devjiwon/devjiwon.github.io.git참고로 저는 이번에 노트북을 새로 장만했기 때문에, 처음부터 설정해야 할 것들이 있었습니다.3. Brew, ruby 설치jekyll로 깃허브 블로그를 만들기 위해선 ruby 설치가 필수입니다. ruby와의 7년전 추억을 뒤로하고, 설치를 해봅니다..ruby를 설치하기 전에 brew를 설치해야 합니다.Homebrew 홈페이지에 들어가서 brew를 설치하기 위한 명령어를 복사해줍니다./bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"설치가 완료되면, 아래 명령어를 입력해주세요.% (echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; /Users/jim      /.zprofile% eval \"$(/opt/homebrew/bin/brew shellenv)\"brew를 통해 ruby를 설치해봅시니다.brew updatebrew install rbenv ruby-build# 설치 확인rbenv versions# 아래의 형태로 나오면 system ruby 사용중* system (set by /Users/...# 해당 명령어를 통해 설치가능한 ruby 버전 확인rbenv install -l# 버전을 입력하여 루비 설치rbenv install {version}루비를 설치했다면, 루비의 경로를 설정해줍니다. 저는 이 부분을 놓쳐서 배포할 때 에러를 만났습니다.vi ~/.zshrc[[ -d ~/.rbenv  ]] &amp;&amp; \\  export PATH=${HOME}/.rbenv/bin:${PATH} &amp;&amp; \\  eval \"$(rbenv init -)\"# 저장 후 적용source ~/.zshrc4. Jekelly 템플릿 다운맘에 드는 지킬 테마를 찾아주세요! 다양한 지킬 테마는 여기서 확인할 수 있습니다.http://jekyllthemes.org/저는 그 중 Chirpy 테마가 제일 맘에 들었습니다.마음에 드는 깃허브에 들어가서 소스코드를 다운로드 해주세요.압출을 풀어서 프로젝트 전체를 본인의 레포지토리에 복사붙여넣기를 해주세요.그럼 이제 한 번 실행시켜볼까요?아래 명령어를 통해 jekyll 서버를 실행시키면, http://127.0.0.1:4000/ 에서 확인이 가능합니다!jekyll serve5. 배포깃에 푸시하기 전에 로컬에서 정상적으로 확인이 되는지 먼저 확인해보면, 예상치 못한 오류를 줄일 수 있으니 로컬에서 한 번 실행시켜보세요!자, 이제 배포할 준비가 끝났다면, push 해주세요.배포 상황은 Actions 탭에서 확인이 가능합니다. 만약 정상적으로 초록색 표시가 뜨지 않고, 빨간색으로 오류가 발생했다면 detail을 들어가서 오류 메세지를 확인하세요.제가 직면한 첫번째 문제는 위에서 설치한 ruby의 경로를 global로 설정하지 않아 발생한 문제였습니다. global로 수정해주니 바로 해결!문제가 없다면 5~10분 정도 시간이 지난 후, 본인의 블로그가 잘 배포된 걸 확인할 수 있습니다.https://devjiwon.github.io/마무리혹시라도 깃 블로그를 만들면서 어려운 부분이 있다면, 댓글 남겨주시면 도움드리겠습니다."
  }
  
]

